Dandu Rajasekhar Reddy				
Title:	Consultant
Location:	Bangalore, India
Languages:
Email-id :
Mobile number:	Telugu (native), English (fluent)
RAJASEKHAR-REDDY.A.DANDU@CAPGEMINI.COM
+91 9581934385


Experience Summary

•	4.3 years of experience in designing, developing, and optimizing scalable software solutions.
•	4 years of experience in backend development using Java, Struts, Hibernate and Spring Boot for
 building robust and scalable applications.
•	2 years of experience in developing RESTAPIs using Java and Spring boot.
•	Hands on experience in J2EE frameworks like Struts 1 & 2, Spring Boot.
•	Hands on experience in ORM Tools using Hibernate, Spring Data JPA.
•	Hands on experience in Legacy Application using Struts, Jsp and Servlets.
•	Hands on experience in Source repository tools GIT.
•	Good experience in application build tools Maven.
•	Involved in client calls at various levels to getting keen understanding of the Requirements.
KEY SKILLS: 
•	Programming Languages:  Java, J2EE, PHP
•	Frontend Development:   HTML5, CSS3, JavaScript
•	Backend Development:   Struts 1 &2, Spring Boot, RESTful APIs, Swagger, Postman
•	Database Management:  SQL, PL/SQL
•	Build Tools: Maven, Ant
•	Software Development:   Java , J2EE , Spring Boot, PHP
•	System Integration & Scalability:   RESTful API Development
•	Collaboration & Problem-Solving:  Cross-functional Teamwork, Agile & Waterfall Development, Requirement Analysis
•	Messaging Services: Apache Kafka
Experience
Project 1: Cummins
Industry: Manufacturing
Description:
•	Worked on a manufacturing product that managed the ordering of heavy machinery parts services. The project involved integrating multiple external systems and ensuring secure authentication using Single sign On (SSO) . Developed RESTful APIs using Java and Spring Boot while implementing best practices for scalability, security, and maintainability.
Role: Senior Systems Engineer
Duration: Mar 2023 – Feb 2025
Responsibilities:
•	Developed robust backend services leveraging Spring Data JPA for XML-based entity mapping, enhancing data management and integration capabilities.
•	Designed the data model and developed Swagger APIs to facilitate the creation and updating of participant records, optimizing service functionality and usability.
•	Engaged in the development of web applications using JSP, Servlets, and Struts, ensuring high-quality user experiences through dynamic content rendering.
•	Participated in technical reviews and code walkthrough sessions, fostering a culture of knowledge sharing and continuous improvement within the development team.
•	Utilized Java, Spring Boot, and Oracle for application design and development, focusing on delivering scalable and maintainable solutions.
•	Designed and developed Restful web services using the Jersey framework, enhancing API functionality and supporting seamless integration with front-end applications.
•	Utilized the Spring MVC architecture to integrate web components with business services, ensuring efficient request handling and response delivery.
•	Developed a robust Data Access Layer (DAL) using Spring Data and Hibernate ORM, facilitating effective data interactions and business logic separation.
•	Wrote application-level code to interact with APIs and web services using AJAX, JSON enhancing client-side functionality and performance.
•	Built and managed Java applications using Maven, streamlining the build process and ensuring efficient deployment of Java/J2EE applications through application servers.


Technologies Used:
•	Backend: Java, Struts, Spring Boot, Spring REST, Spring Security, Oracle (PL/SQL)
•	Build Tools: Maven
•	Authentication:  Azure AD / Salesforce


Project 2: Cummins
Industry: Manufacturing
Description:
•	Worked on a manufacturing product that managed claims for users who ordered parts. Issues related to damage and shipping were raised as requests for refunds or repairs. The projects involved enhancing new features, modifying claim process logic, modernizing legacy applications, and improving system reliability.
•	package com.microservices.product_service.config.client;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class ClientConfig {
    @Bean
    // @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }
}
•	
•	package com.microservices.product_service.config.mapper;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.json.JsonMapper;
import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
// @EnableJpaAuditing
public class MapperConfig {

    @Bean
    public ObjectMapper objectsMapper() {
        return new JsonMapper().enable(SerializationFeature.INDENT_OUTPUT);
    }

    @Bean
    public ModelMapper modelMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
                .setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }

}
•	
•	package com.microservices.product_service.constant;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public abstract class AppConstant {

    public static final String LOCAL_DATE_FORMAT = "dd-MM-yyyy";
    public static final String LOCAL_DATE_TIME_FORMAT = "dd-MM-yyyy__HH:mm:ss:SSSSSS";
    public static final String ZONED_DATE_TIME_FORMAT = "dd-MM-yyyy__HH:mm:ss:SSSSSS";
    public static final String INSTANT_FORMAT = "dd-MM-yyyy__HH:mm:ss:SSSSSS";

    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public abstract static class DiscoveredDomainsApi {
        public static final String USER_SERVICE_HOST = "http://USER-SERVICE/user-service";
        public static final String USER_SERVICE_API_URL = "http://USER-SERVICE/user-service/api/users";

        public static final String PRODUCT_SERVICE_HOST = "http://PRODUCT-SERVICE/product-service";
        public static final String PRODUCT_SERVICE_API_URL = "http://PRODUCT-SERVICE/product-service/api/products";

        public static final String ORDER_SERVICE_HOST = "http://ORDER-SERVICE/order-service";
        public static final String ORDER_SERVICE_API_URL = "http://ORDER-SERVICE/order-service/api/orders";

        public static final String FAVOURITE_SERVICE_HOST = "http://FAVOURITE-SERVICE/favourite-service";
        public static final String FAVOURITE_SERVICE_API_URL = "http://FAVOURITE-SERVICE/favourite-service/api/favourites";

        public static final String PAYMENT_SERVICE_HOST = "http://PAYMENT-SERVICE/payment-service";
        public static final String PAYMENT_SERVICE_API_URL = "http://PAYMENT-SERVICE/payment-service/api/payments";

        public static final String SHIPPING_SERVICE_HOST = "http://SHIPPING-SERVICE/shipping-service";
        public static final String SHIPPING_SERVICE_API_URL = "http://SHIPPING-SERVICE/shipping-service/api/shippings";
    }

}
•	
•	package com.microservices.product_service.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.data.domain.Page;

import com.microservices.product_service.dto.CategoryDto;
import com.microservices.product_service.service.CategoryService;
import com.microservices.product_service.service.ProductService;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import org.springframework.web.bind.annotation.*;
import java.util.List;

import org.springframework.http.HttpHeaders;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/categories")
@RequiredArgsConstructor
@Slf4j
public class CategoryController {
    
    @Autowired
    private final CategoryService categoryService;

    // Get a list of all categories
    @GetMapping
    public ResponseEntity<Flux<List<CategoryDto>>> findAll() {
        log.info("CategoryDto List, controller; fetch all categories");
        return ResponseEntity.ok(categoryService.findAll());
    }

   // Get all list categories with paging
    @GetMapping("/paging")
    public ResponseEntity<Page<CategoryDto>> getAllCategories(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        Page<CategoryDto> categoryPage = categoryService.findAllCategory(page, size);
        return new ResponseEntity<>(categoryPage, HttpStatus.OK);
    }

    @GetMapping("/paging-and-sorting")
    public ResponseEntity<List<CategoryDto>> getAllEmployees(
            @RequestParam(defaultValue = "0") Integer pageNo,
            @RequestParam(defaultValue = "10") Integer pageSize,
            @RequestParam(defaultValue = "categoryId") String sortBy) {

        List<CategoryDto> list = categoryService.getAllCategories(pageNo, pageSize, sortBy);

        return new ResponseEntity<List<CategoryDto>>(list, new HttpHeaders(), HttpStatus.OK);
    }

    // Get detailed information of a specific category:
    @GetMapping("/{categoryId}")
    public ResponseEntity<CategoryDto> findById(@PathVariable("categoryId")
                                                @NotBlank(message = "Input must not be blank")
                                                @Valid final String categoryId) {
        log.info("CategoryDto, resource; fetch category by id");
        return ResponseEntity.ok(categoryService.findById(Integer.parseInt(categoryId)));
    }

    //     Create a new category
    @PostMapping
    public ResponseEntity<Mono<CategoryDto>> save(@RequestBody @NotNull(message = "Input must not be NULL")
                                                  @Valid final CategoryDto categoryDto) {
        log.info("CategoryDto, resource; save category");
        return ResponseEntity.ok(categoryService.save(categoryDto));
    }

    // Update information of all category
    @PutMapping
    public ResponseEntity<CategoryDto> update(@RequestBody
                                              @NotNull(message = "Input must not be NULL")
                                              @Valid final CategoryDto categoryDto) {
        log.info("CategoryDto, resource; update category");
        return ResponseEntity.ok(categoryService.update(categoryDto));
    }

    // Update information of a category
    @PutMapping("/{categoryId}")
    public ResponseEntity<CategoryDto> update(@PathVariable("categoryId")
                                              @NotBlank(message = "Input must not be blank")
                                              @Valid final String categoryId,
                                              @RequestBody @NotNull(message = "Input must not be NULL")
                                              @Valid final CategoryDto categoryDto) {
        log.info("CategoryDto, resource; update category with categoryId");
        return ResponseEntity.ok(categoryService.update(Integer.parseInt(categoryId), categoryDto));
    }

    // Delete a category
    @DeleteMapping("/{categoryId}")
    public ResponseEntity<Boolean> deleteById(@PathVariable("categoryId") final String categoryId) {
        log.info("Boolean, resource; delete category by id");
        categoryService.deleteById(Integer.parseInt(categoryId));
        return ResponseEntity.ok(true);
    }

}
•	
•	package com.microservices.product_service.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.microservices.product_service.dto.ProductDto;
import com.microservices.product_service.service.ProductService;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Slf4j
public class ProductController {
    
    @Autowired
    private final ProductService productService;

    // Get a list of all products
    @GetMapping
    public Flux<List<ProductDto>> findAll() {
        log.info("ProductDto List, controller; fetch all categories");
        return productService.findAll();
    }

    // Get detailed information of a specific product
    @GetMapping("/{productId}")
    public ResponseEntity<ProductDto> findById(@PathVariable("productId")
                                               @NotBlank(message = "Input must not be blank!")
                                               @Valid final String productId) {
        log.info("ProductDto, resource; fetch product by id");
        return ResponseEntity.ok(productService.findById(Integer.parseInt(productId)));
    }
    // Create a new product
    @PostMapping
    public ResponseEntity<ProductDto> save(@RequestBody
                                           @NotNull(message = "Input must not be NULL!")
                                           @Valid final ProductDto productDto) {
        log.info("ProductDto, resource; save product");
        return ResponseEntity.ok(productService.save(productDto));
    }

    // Update information of all product
    @PutMapping
    public ResponseEntity<ProductDto> update(@RequestBody
                                             @NotNull(message = "Input must not be NULL!")
                                             @Valid final ProductDto productDto) {
        log.info("ProductDto, resource; update product");
        return ResponseEntity.ok(productService.update(productDto));
    }


    // Update information of a product:
    @PutMapping("/{productId}")
    public ResponseEntity<ProductDto> update(@PathVariable("productId")
                                             @NotBlank(message = "Input must not be blank!")
                                             @Valid final String productId,
                                             @RequestBody
                                             @NotNull(message = "Input must not be NULL!")
                                             @Valid final ProductDto productDto) {
        log.info("ProductDto, resource; update product with productId");
        return ResponseEntity.ok(productService.update(Integer.parseInt(productId), productDto));
    }

    // Delete a product
    @DeleteMapping("/{productId}")
    public ResponseEntity<Boolean> deleteById(@PathVariable("productId") final String productId) {
        log.info("Boolean, resource; delete product by id");
        productService.deleteById(Integer.parseInt(productId));
        return ResponseEntity.ok(true);
    }
    
}
•	
•	package com.microservices.product_service.dto.response.collection;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collection;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class DtoCollectionResponse<T> {
    private Collection<T> collection;
}
•	
•	package com.microservices.product_service.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serial;
import java.io.Serializable;
import java.util.Set;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class CategoryDto implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    private Integer categoryId;
    private String categoryTitle;
    private String imageUrl;

    @JsonProperty("subCategory")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Set<CategoryDto> subCategoriesDtos;

    @JsonProperty("parentCategory")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private CategoryDto parentCategoryDto;


    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Set<ProductDto> productDtos;

}
•	
•	package com.microservices.product_service.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;

@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Data
@Builder
public class ProductDto implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;

    private Integer productId;
    private String productTitle;
    private String imageUrl;
    private String sku;
    private Double priceUnit;
    private Integer quantity;

    @JsonProperty("category")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private CategoryDto categoryDto;

}
•	
•	package com.microservices.product_service.entity;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonFormat.Shape;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;

import jakarta.persistence.*;
import java.io.Serial;
import java.io.Serializable;
import java.time.Instant;

@MappedSuperclass
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PROTECTED)
@Data
public abstract class AbstractMappedEntity implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;

    @CreatedDate
    @JsonFormat(shape = Shape.STRING)
    @Column(name = "created_at",updatable= false)
    private Instant createAt;

    @LastModifiedDate
    @JsonFormat(shape = Shape.STRING)
    @Column(name = "updated_at")
    private Instant updateAt;

}
•	
•	package com.microservices.product_service.entity;
import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.util.Set;

import org.springframework.data.jpa.domain.support.AuditingEntityListener;

@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true, exclude = {"subCategories", "parentCategory", "products"})
@Data
@Builder
@Entity
@Table(name = "categories")
@EntityListeners(AuditingEntityListener.class)
public final class Category extends AbstractMappedEntity implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "category_id", unique = true, nullable = false, updatable = false)
    private Integer categoryId;

    @Column(name = "category_title", unique = true, nullable = false )
    private String categoryTitle;

    @Column(name = "image_url")
    private String imageUrl;

    @JsonIgnore
    @OneToMany(mappedBy = "parentCategory", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<Category> subCategories;

    
    @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinColumn(name = "parent_category_id")
    private Category parentCategory;

    @JsonIgnore
    @OneToMany(mappedBy = "category", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<Product> products;

}
•	
•	package com.microservices.product_service.entity;

import java.math.BigDecimal;

import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import java.io.Serial;
import java.io.Serializable;

@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true, exclude = {"category"})
@Data
@Builder
@Entity
@Table(name = "products")
@EntityListeners(AuditingEntityListener.class)
public final class Product extends AbstractMappedEntity implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "product_id", unique = true, nullable = false, updatable = false)
    private Integer productId;

    @Column(name = "product_title" ,unique = true)
    private String productTitle;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(unique = true)
    private String sku;

    @Column(name = "price_unit", columnDefinition = "decimal")
    private Double priceUnit;

    @Column(name = "quantity")
    private Integer quantity;

    @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinColumn(name = "category_id")
    private Category category;

}
•	
•	package com.microservices.product_service.exception.payload;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.ser.ZonedDateTimeSerializer;
import com.microservices.product_service.constant.AppConstant;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;

import java.io.Serial;
import java.io.Serializable;
import java.time.ZonedDateTime;

@RequiredArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ExceptionMessage implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;

    @JsonSerialize(using = ZonedDateTimeSerializer.class)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = AppConstant.ZONED_DATE_TIME_FORMAT)
    private final ZonedDateTime timestamp;

    @JsonInclude(value = JsonInclude.Include.NON_NULL)
    private Throwable throwable;
    private final HttpStatus httpStatus;
    private final String message;

}
•	
•	package com.microservices.product_service.exception.wrapper;

import java.io.Serial;

public class CategoryNotFoundException extends RuntimeException {
    @Serial
    private static final long serialVersionUID = 1L;

    public CategoryNotFoundException() {
        super();
    }

    public CategoryNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public CategoryNotFoundException(String message) {
        super(message);
    }

    public CategoryNotFoundException(Throwable cause) {
        super(cause);
    }

}
•	
•	package com.microservices.product_service.exception.wrapper;

import java.io.Serial;

public class ProductNotFoundException extends RuntimeException {
    @Serial
    private static final long serialVersionUID = 1L;

    public ProductNotFoundException() {
        super();
    }

    public ProductNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public ProductNotFoundException(String message) {
        super(message);
    }

    public ProductNotFoundException(Throwable cause) {
        super(cause);
    }
}
•	
•	package com.microservices.product_service.exception;

import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Objects;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.BindException;
import org.springframework.web.ErrorResponse;
import org.springframework.web.HttpMediaTypeNotAcceptableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.microservices.product_service.exception.payload.ExceptionMessage;
import com.microservices.product_service.exception.wrapper.CategoryNotFoundException;
import com.microservices.product_service.exception.wrapper.ProductNotFoundException;

import io.swagger.v3.oas.annotations.Hidden;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Hidden
@RestControllerAdvice
@Slf4j
@RequiredArgsConstructor
public class ApiExceptionHandler {

    @ExceptionHandler(value = {
            MethodArgumentNotValidException.class,
            HttpMessageNotReadableException.class,
    })
    public <T extends BindException> ResponseEntity<ExceptionMessage> handleValidationException(final T e) {
        log.info("**ApiExceptionHandler controller, handle validation exception*\n");
        final var badRequest = HttpStatus.BAD_REQUEST;

        return new ResponseEntity<>(
                ExceptionMessage.builder()
                        .message("*" + Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage() + "!**")
                        .httpStatus(badRequest)
                        .timestamp(ZonedDateTime
                                .now(ZoneId.systemDefault()))
                        .build(), badRequest);
    }

    @ExceptionHandler(value = {CategoryNotFoundException.class, ProductNotFoundException.class,})
    public <T extends RuntimeException> ResponseEntity<ExceptionMessage> handleApiRequestException(final T e) {
        log.info("**ApiExceptionHandler controller, handle API request*\n");
        final var badRequest = HttpStatus.BAD_REQUEST;

        return new ResponseEntity<>(
                ExceptionMessage.builder()
                        .message("#### " + e.getMessage() + "! ####")
                        .httpStatus(badRequest)
                        .timestamp(ZonedDateTime
                                .now(ZoneId.systemDefault()))
                        .build(), badRequest);
    }

    

}
•	
•	package com.microservices.product_service.helper;

import com.microservices.product_service.entity.Category;
import com.microservices.product_service.dto.CategoryDto;

import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public interface CategoryMappingHelper {

    static CategoryDto map(final Category category) {
        final var parentCategory = Optional.ofNullable(category.getParentCategory())
                .orElseGet(Category::new);
        return CategoryDto.builder()
                .categoryId(category.getCategoryId())
                .categoryTitle(category.getCategoryTitle())
                .imageUrl(category.getImageUrl())
                .parentCategoryDto(
                        CategoryDto.builder()
                                .categoryId(parentCategory.getCategoryId())
                                .categoryTitle(parentCategory.getCategoryTitle())
                                .imageUrl(parentCategory.getImageUrl())
                                .build()
                )
                .build();
    }

    static Category map(CategoryDto categoryDto) {
        final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto())
                .orElseGet(CategoryDto::new);
        return Category.builder()
                .categoryId(categoryDto.getCategoryId())
                .categoryTitle(categoryDto.getCategoryTitle())
                .imageUrl(categoryDto.getImageUrl())
                .parentCategory(Category.builder()
                        .categoryId(parentCategoryDto.getCategoryId())
                        .categoryTitle(parentCategoryDto.getCategoryTitle())
                        .imageUrl(parentCategoryDto.getImageUrl())
                        .build())
                .build();
    }

    
    
 static CategoryDto mapCategory(Category category, boolean includeSubCategories) {
        if (category == null) return null;

        Set<CategoryDto> subCategories = null;
        if (includeSubCategories && category.getSubCategories() != null) {
            subCategories = category.getSubCategories().stream()
                    .map(sub -> mapCategory(sub, false)) // avoid deep recursion
                    .collect(Collectors.toSet());
        }

        return CategoryDto.builder()
                .categoryId(category.getCategoryId())
                .categoryTitle(category.getCategoryTitle())
                .imageUrl(category.getImageUrl())
                // .parentCategoryDto(mapCategory(category.getParentCategory(), false)) // avoid deep recursion
                .parentCategoryDto(map(category.getParentCategory())) // avoid deep recursion
                .subCategoriesDtos(subCategories)
                .build();
    }

     static Category mapCategoryDto(CategoryDto dto) {
        if (dto == null) return null;

        return Category.builder()
                .categoryId(dto.getCategoryId())
                .categoryTitle(dto.getCategoryTitle())
                .imageUrl(dto.getImageUrl())
                .parentCategory(mapCategoryDto(dto.getParentCategoryDto()))
                .build();
    }

}
•	
•	package com.microservices.product_service.helper;



import com.microservices.product_service.dto.CategoryDto;
import com.microservices.product_service.dto.ProductDto;
import com.microservices.product_service.entity.Category;
import com.microservices.product_service.entity.Product;

public interface ProductMappingHelper {
    static ProductDto mapSubCategories(final Product product) {
        return ProductDto.builder()
                .productId(product.getProductId())
                .productTitle(product.getProductTitle())
                .imageUrl(product.getImageUrl())
                .sku(product.getSku())
                .priceUnit(product.getPriceUnit())
                .quantity(product.getQuantity())
                .categoryDto(CategoryMappingHelper.mapCategory(product.getCategory(), true))
                .build();
    }
    
    static ProductDto map(final Product product) {
        return ProductDto.builder()
                .productId(product.getProductId())
                .productTitle(product.getProductTitle())
                .imageUrl(product.getImageUrl())
                .sku(product.getSku())
                .priceUnit(product.getPriceUnit())
                .quantity(product.getQuantity())
                .categoryDto(
                        CategoryDto.builder()
                                .categoryId(product.getCategory().getCategoryId())
                                .categoryTitle(product.getCategory().getCategoryTitle())
                                .imageUrl(product.getCategory().getImageUrl())
                                .build())
                .build();
    }

    static Product map(final ProductDto productDto) {
        return Product.builder()
                .productId(productDto.getProductId())
                .productTitle(productDto.getProductTitle())
                .imageUrl(productDto.getImageUrl())
                .sku(productDto.getSku())
                .priceUnit(productDto.getPriceUnit())
                .quantity(productDto.getQuantity())
                .category(
                        Category.builder()
                                .categoryId(productDto.getCategoryDto().getCategoryId())
                                .categoryTitle(productDto.getCategoryDto().getCategoryTitle())
                                .imageUrl(productDto.getCategoryDto().getImageUrl())
                                .build())
                .build();
    }
    


}


•	
•	package com.microservices.product_service.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import com.microservices.product_service.entity.Category;

public interface CategoryRepository extends JpaRepository<Category,Integer > {

    Page<Category> findAll(Pageable pageable);

    Page<Category> findByCategoryTitleContaining(String categoryTitle, Pageable pageable);

    Optional<Category> findByCategoryId(Integer categoryId);

    Optional<Category> findByCategoryTitle(String categoryTitle);
    
    List<Category> findByParentCategory_CategoryId(Integer parentCategoryId);
    
   
    
}
•	
•	package com.microservices.product_service.repository;


import com.microservices.product_service.entity.Category;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.PagingAndSortingRepository;

public interface CategoryRepositoryPagingAndSorting extends PagingAndSortingRepository<Category, Integer> {

    @Query("SELECT c FROM Category c")
    Page<Category> findAllPagedAndSortedCategories(Pageable pageable);

}
•	
•	package com.microservices.product_service.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.microservices.product_service.entity.Product;


public interface ProductRepository extends JpaRepository<Product, Integer >{

    boolean existsBySku(String sku);
    
}
•	
•	package com.microservices.product_service.service.impl;

import com.microservices.product_service.dto.CategoryDto;
import com.microservices.product_service.entity.Category;
import com.microservices.product_service.exception.wrapper.CategoryNotFoundException;
// import com.microservices.product_service.exception.wrapper.CategoryNotFoundException;
import com.microservices.product_service.helper.CategoryMappingHelper;
import com.microservices.product_service.repository.CategoryRepository;
import com.microservices.product_service.repository.CategoryRepositoryPagingAndSorting;
import com.microservices.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.modelmapper.ModelMapper;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Slf4j
@RequiredArgsConstructor
@Service
public class CategoryServiceImpl implements CategoryService {
    private final ModelMapper modelMapper;

    @Autowired
    private final CategoryRepository categoryRepository;

    @Autowired
    private final CategoryRepositoryPagingAndSorting categoryRepositoryPagingAndSorting;

    @Override
    public Flux<List<CategoryDto>> findAll() {
        log.info("Category List Service, fetch all category");
        return Flux.just(categoryRepository.findAll())
                .flatMap(categories -> Flux.fromIterable(categories)
                                .map(CategoryMappingHelper::map)
                                .distinct()
                                .collectList()
                )
                .map(categoryDtos -> {
                    log.info("Categories fetched successfully");
                    return categoryDtos;
                })
                .onErrorResume(throwable -> {
                    log.error("Error while fetching categories: " + throwable.getMessage());
                    return Mono.just(Collections.emptyList());
                });
    }


    @Override
    public Page<CategoryDto> findAllCategory(int page, int size) {
        log.info("*** CategoryDto List, service; fetch all categories ***");

        Pageable pageable = PageRequest.of(page, size);
        Page<Category> categoryPage = categoryRepository.findAll(pageable);

        List<CategoryDto> categoryDtos = categoryPage.getContent()
                .stream()
                .map(CategoryMappingHelper::map)
                .distinct()
                .collect(Collectors.toList());

        return new PageImpl<>(categoryDtos, pageable, categoryPage.getTotalElements());
    }


    // Paging and Sorting Categories
    @Override
    public List<CategoryDto> getAllCategories(Integer pageNo, Integer pageSize, String sortBy) {
        Pageable paging = PageRequest.of(pageNo, pageSize, Sort.by(sortBy));

        Page<Category> pagedResult = categoryRepositoryPagingAndSorting.findAllPagedAndSortedCategories(paging);

        if (pagedResult.hasContent()) {
            return pagedResult.getContent()
                    .stream()
                    .map((element) -> modelMapper.map(element, CategoryDto.class))
                    .collect(Collectors.toList());
        } else {
            return new ArrayList<>();
        }
    }


    @Override
    public CategoryDto findById(Integer categoryId) {
        log.info("CategoryDto Service, fetch category by id");
        // return new CategoryDto();
        return categoryRepository.findById(categoryId)
                .map(CategoryMappingHelper::map)
                .orElseThrow(() -> new CategoryNotFoundException(String.format("Category with id[%d] not found", categoryId)));
    }

    @Override
    public Mono<CategoryDto> save(CategoryDto categoryDto) {
        log.info("CategoryDto, service; save category");
        // return Mono.just(new CategoryDto());
        return Mono.just(categoryDto)
                .map(CategoryMappingHelper::map)
                .flatMap(category ->
                        Mono.fromCallable(() -> CategoryMappingHelper.map(categoryRepository.save(category)))
                                .onErrorMap(DataIntegrityViolationException.class, e -> new CategoryNotFoundException("Bad Request", e))
                );
    }

    @Override
    public CategoryDto update(CategoryDto categoryDto) {
        log.info("CategoryDto Service, update category");
        try {
            Category existingCategory = categoryRepository.findByCategoryId(categoryDto.getCategoryId())
                    .orElseThrow(() -> new CategoryNotFoundException("Category not found with id: " + categoryDto.getCategoryId()));

            BeanUtils.copyProperties(categoryDto, existingCategory, "categoryId", "parentCategoryDto");

            if (categoryDto.getParentCategoryDto() != null) {
                existingCategory.setParentCategory(CategoryMappingHelper.map(categoryDto.getParentCategoryDto()));
            }

            return CategoryMappingHelper.map(categoryRepository.save(existingCategory));
        } catch (CategoryNotFoundException e) {
            log.error("Error updating category. Category with id [{}] not found.", categoryDto.getCategoryId());
            throw new CategoryNotFoundException(String.format("Category with id [%d] not found.", categoryDto.getCategoryId()), e);
        } catch (DataIntegrityViolationException e) {
            log.error("Error updating category: Data integrity violation", e);
            throw new CategoryNotFoundException("Error updating category: Data integrity violation", e);
        } catch (Exception e) {
            log.error("Error updating category", e);
            throw new CategoryNotFoundException("Error updating category", e);
        }
    }


    @Override
    public CategoryDto update(Integer categoryId, CategoryDto categoryDto) {
        log.info("CategoryDto Service: Updating category with categoryId");
        // return new CategoryDto();
        try {
            // Check if the category exists
            CategoryDto existingCategoryDto = this.findById(categoryId);
            // Convert CategoryDto to Category and update the fields
            Category existingCategory = CategoryMappingHelper.map(existingCategoryDto);
            BeanUtils.copyProperties(categoryDto, existingCategory, "categoryId", "parentCategoryDto");

            if (categoryDto.getParentCategoryDto() != null) {
                existingCategory.setParentCategory(CategoryMappingHelper.map(categoryDto.getParentCategoryDto()));
            }

            // Save the updated category to the database
            Category updatedCategory = categoryRepository.save(existingCategory);

            // Map the updated Category back to CategoryDto and return
            return CategoryMappingHelper.map(updatedCategory);
        } catch (CategoryNotFoundException e) {
            log.error("Error updating category. Category with id [{}] not found.", categoryId);
            throw new CategoryNotFoundException(String.format("Category with id [%d] not found.", categoryId), e);
        } catch (DataIntegrityViolationException e) {
            log.error("Error updating category: Data integrity violation", e);
            throw new CategoryNotFoundException("Error updating category: Data integrity violation", e);
        } catch (Exception e) {
            log.error("Error updating category", e);
            throw new CategoryNotFoundException("Error updating category", e);
        }
    }


    @Override
    public void deleteById(Integer categoryId) {
        log.info("Void Service, delete category by id");
        try {
            categoryRepository.deleteById(categoryId);
        } catch (CategoryNotFoundException e) {
            log.error("Error delete category", e);
            throw new CategoryNotFoundException("Error updating category", e);
        }
    }

}
•	
•	package com.microservices.product_service.service.impl;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import com.microservices.product_service.dto.CategoryDto;
import com.microservices.product_service.dto.ProductDto;
import com.microservices.product_service.entity.Category;
import com.microservices.product_service.entity.Product;
import com.microservices.product_service.exception.wrapper.CategoryNotFoundException;
import com.microservices.product_service.exception.wrapper.ProductNotFoundException;
import com.microservices.product_service.helper.CategoryMappingHelper;
import com.microservices.product_service.helper.ProductMappingHelper;
import com.microservices.product_service.repository.CategoryRepository;
import com.microservices.product_service.repository.ProductRepository;
import com.microservices.product_service.service.ProductService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@RequiredArgsConstructor
@Service
public class ProductServiceImpl implements ProductService {

    @Autowired
    private final ProductRepository productRepository;
    
    @Autowired
    private final CategoryRepository categoryRepository;

    @Override
    public Flux<List<ProductDto>> findAll() {
        log.info("ProductDto List, service, fetch all products");
        return Flux.defer(() -> {
                    List<ProductDto> productDtos = productRepository.findAll()
                            .stream()
                            .map(ProductMappingHelper::map)
                            .distinct()
                            .toList();
                    return Flux.just(productDtos);
                })
                .onErrorResume(throwable -> {
                    log.error("Error while fetching products: " + throwable.getMessage());
                    return Flux.empty();
                });
    }

    @Override
    public ProductDto findById(Integer productId) {
        log.info("ProductDto, service; fetch product by id");
        return productRepository.findById(productId)
                .map(ProductMappingHelper::map)
                .orElseThrow(() -> new ProductNotFoundException(String.format("Product with id[%d] not found", productId)));
        
    }

    @Override
    public ProductDto save(ProductDto productDto) {
        log.info("ProductDto, service; save product");
        try {
           
        if (productRepository.existsBySku(productDto.getSku())) {
            throw new RuntimeException("Product with SKU already exists: " + productDto.getSku());
        }

        // Handle category creation or retrieval
        Category category = getOrCreateCategory(productDto.getCategoryDto());

        // Map DTO to entity
        Product product = ProductMappingHelper.map(productDto);
        product.setCategory(category);
        // Save product
        Product savedProduct = productRepository.save(product);
        return ProductMappingHelper.map(savedProduct);
        } catch (DataIntegrityViolationException e) {
            log.error("Error saving product: Data integrity violation", e);
            throw new ProductNotFoundException("Error saving product: Data integrity violation", e);
        } catch (RuntimeException e) {
            log.error("Error saving product", e);
            throw new ProductNotFoundException("Error saving product", e);
        }
        
    }
    
  
    

    @Override
    public ProductDto update(ProductDto productDto) {
        log.info("ProductDto, service; update product");

        Product existingProduct = productRepository.findById(productDto.getProductId())
                .orElseThrow(() -> new ProductNotFoundException("Product not found with id: " + productDto.getProductId()));

       
        BeanUtils.copyProperties(productDto, existingProduct, "productId", "category");

        // Handle category update
        if (productDto.getCategoryDto() != null && productDto.getCategoryDto().getCategoryId() != null) {
            Category category = categoryRepository.findByCategoryId(productDto.getCategoryDto().getCategoryId())
                    .orElseThrow(() -> new CategoryNotFoundException("Category not found with id: " + productDto.getCategoryDto().getCategoryId()));
            existingProduct.setCategory(category);
        }
        Product updatedProduct = productRepository.save(existingProduct);
        return ProductMappingHelper.map(updatedProduct);
    }
    

    @Override
    public ProductDto update(Integer productId, ProductDto productDto) {
        log.info("ProductDto, service; update product with productId");

        // Check Product Exists in DB
        Product existingProduct = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with id: " + productId));

        // Update Product using BeanUtils.copyProperties
        BeanUtils.copyProperties(productDto, existingProduct, "productId", "category");

    // Handle category update
        if (productDto.getCategoryDto() != null && productDto.getCategoryDto().getCategoryId() != null) {
            Category category = categoryRepository.findByCategoryId(productDto.getCategoryDto().getCategoryId())
                    .orElseThrow(() -> new CategoryNotFoundException("Category not found with id: " + productDto.getCategoryDto().getCategoryId()));
            existingProduct.setCategory(category);
        }

        // Save to Database
        Product updatedProduct = productRepository.save(existingProduct);
        return ProductMappingHelper.map(updatedProduct);
    }

    @Override
    public void deleteById(Integer productId) {
        log.info("Void, service; delete product by id");
        this.productRepository.delete(ProductMappingHelper.map(this.findById(productId)));
    }

    private Category getOrCreateCategory(CategoryDto dto) {
        // Step 1: Handle parent category if present
        Category parentCategory = null;
        if (dto.getParentCategoryDto() != null) {
            parentCategory = getOrCreateCategory(dto.getParentCategoryDto());
        }

        // Step 2: Check if main category exists 
        Optional<Category> existingCategory = categoryRepository.findByCategoryTitle(dto.getCategoryTitle());
        Category category;
        if (existingCategory.isPresent()) {
            category = existingCategory.get();
        } else {
            category = Category.builder()
                    .categoryTitle(dto.getCategoryTitle())
                    .imageUrl(dto.getImageUrl())
                    .parentCategory(parentCategory)
                    .build();
            category = categoryRepository.save(category);
        }

        // Step 3: Handle subcategories if present
        if (dto.getSubCategoriesDtos() != null && !dto.getSubCategoriesDtos().isEmpty()) {
            for (CategoryDto subDto : dto.getSubCategoriesDtos()) {
                Optional<Category> existingSub = categoryRepository.findByCategoryTitle(subDto.getCategoryTitle());
                if (existingSub.isEmpty()) {
                    Category subCategory = Category.builder()
                            .categoryTitle(subDto.getCategoryTitle())
                            .imageUrl(subDto.getImageUrl())
                            .parentCategory(category)
                            .build();
                    categoryRepository.save(subCategory);
                }
            }
        }
        return category;
    }


}
•	
•	package com.microservices.product_service.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import com.microservices.product_service.dto.CategoryDto;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;

public interface CategoryService {

    Flux<List<CategoryDto>> findAll();

    Page<CategoryDto> findAllCategory(int page, int size);
    List<CategoryDto> getAllCategories(Integer pageNo, Integer pageSize, String sortBy);



    CategoryDto findById(final Integer categoryId);

    Mono<CategoryDto> save(final CategoryDto categoryDto);

    CategoryDto update(final CategoryDto categoryDto);

    CategoryDto update(final Integer categoryId, final CategoryDto categoryDto);

    void deleteById(final Integer categoryId);

}
•	
•	package com.microservices.product_service.service;

import reactor.core.publisher.Flux;
import java.util.List;
import com.microservices.product_service.dto.ProductDto;

public interface ProductService {
//    List<ProductDto> findAll();
    Flux<List<ProductDto>> findAll();

    ProductDto findById(final Integer productId);

    ProductDto save(final ProductDto productDto);

    ProductDto update(final ProductDto productDto);

    ProductDto update(final Integer productId, final ProductDto productDto);

    void deleteById(final Integer productId);
}
•	
•	package com.microservices.product_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
// @EnableDiscoveryClient
public class ProductServiceApplication {

    public static void main(String[] args) {

       SpringApplication.run(ProductServiceApplication.class, args);
    }

}
•	
•	# server port
server.port=8084

# name local
spring.application.name=PRODUCT-SERVICE

spring.output.ansi.enabled=always

# DataSource configuration
spring.datasource.url=jdbc:mysql://localhost:3306/microservice
spring.datasource.username=root
spring.datasource.password=
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jpa.properties.hibernate.format_sql=false


management.endpoints.web.exposure.include=*

# Eureka Properties
# eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
# eureka.instance.instance-id=${spring.application.name}:${server.port}
# eureka.instance.prefer-ip-address=true
# eureka.instance.ip-address=127.0.0.1

# Logging configuration
logging.file.name=src/main/resources/script/stage_log.log
logging.logback.rollingpolicy.clean-history-on-start=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data=DEBUG
logging.level.org.springframework.boot.autoconfigure.data.rest=DEBUG
logging.level.org.springframework.boot.autoconfigure.orm=DEBUG

# zipkin
# spring.zipkin.base-url=http://localhost:9411
# management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans
# management.tracing.sampling.probability= 1
•	
•	<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>3.5.3</version>
       <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.microservices</groupId>
    <artifactId>Product-Service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Product Service</name>
    <description>Demo project for Spring Boot</description>
    <url/>
    <licenses>
       <license/>
    </licenses>
    <developers>
       <developer/>
    </developers>
    <scm>
       <connection/>
       <developerConnection/>
       <tag/>
       <url/>
    </scm>
    <properties>
       <java.version>17</java.version>
    </properties>
    <dependencies>

       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-validation</artifactId>
       </dependency>
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-webflux</artifactId>
       </dependency>
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-jpa</artifactId>
       </dependency>
             
       <!-- <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
          <version>4.3.0</version>
       </dependency> -->
       <dependency>
          <groupId>com.mysql</groupId>
          <artifactId>mysql-connector-j</artifactId>
          <scope>runtime</scope>
       </dependency>
       <dependency>
          <groupId>org.modelmapper</groupId>
          <artifactId>modelmapper</artifactId>
          <version>2.3.0</version>
       </dependency>
       
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-devtools</artifactId>
          <scope>runtime</scope>
          <optional>true</optional>
       </dependency>
       <dependency>
          <groupId>org.projectlombok</groupId>
          <artifactId>lombok</artifactId>
          <optional>true</optional>
       </dependency>
       
       <!-- <dependency>
          <groupId>io.micrometer</groupId>
          <artifactId>micrometer-tracing-bridge-brave</artifactId>
       </dependency>

       <dependency>
          <groupId>io.zipkin.reporter2</groupId>
          <artifactId>zipkin-reporter-brave</artifactId>

       </dependency> -->
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-actuator</artifactId>
       </dependency>
       <dependency>
          <groupId>org.springdoc</groupId>
          <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
          <version>2.5.0</version> 
       </dependency>
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-test</artifactId>
          <scope>test</scope>
       </dependency>
    </dependencies>

    <build>
       <plugins>
          <plugin>
             <groupId>org.apache.maven.plugins</groupId>
             <artifactId>maven-compiler-plugin</artifactId>
             <configuration>
                <annotationProcessorPaths>
                   <path>
                      <groupId>org.projectlombok</groupId>
                      <artifactId>lombok</artifactId>
                      <version>${lombok.version}</version>
                   </path>
                </annotationProcessorPaths>
             </configuration>
          </plugin>
          <plugin>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-maven-plugin</artifactId>
             <configuration>
                <excludes>
                   <exclude>
                      <groupId>org.projectlombok</groupId>
                      <artifactId>lombok</artifactId>
                   </exclude>
                </excludes>
             </configuration>
          </plugin>
       </plugins>
    </build>

</project>
•	

Role: System Engineer
Duration: May 2022 – Mar 2023
Responsibilities:
•	Designed and developed Restful services, actively participating in pre-inception meetings to gather and clarify requirements, ensuring alignment with project goals before initiating the design process.
•	Utilized the Spring ORM module to seamlessly integrate Spring with Hibernate, effectively implementing Data Access Object (DAO) layers for optimized data management.
•	Implemented SAML 2.0 for user authentication, enhancing the security of Restful web services and safeguarding sensitive data.
•	Employed Postman and Swagger for testing web service calls and documenting API endpoints, facilitating effective communication and understanding of the service functionality.
•	Designed and developed Restful APIs for various project modules based on functional requirements, ensuring consistent and efficient service delivery.
•	Coordinated with front-end teams to integrate lightweight frameworks with JSON APIs, streamlining service requests and enhancing user experience.
•	Implemented all functionalities using Spring Boot and Hibernate ORM, focusing on rapid development and reliable data persistence.
•	Developed Java EE components utilizing Spring MVC, Spring IOC, Spring Transactions and Spring Security modules, enhancing application robustness and security.
•	Designed and developed Restful APIs for various project modules based on functional requirements, ensuring consistent and efficient service delivery.
Technologies Used:
•	Backend: Java 8 ,Hibernate, Spring MVC, Oracle (PL/SQL)
•	Front End:  HTML, CSS, JavaScript, JSTL
•	Servers: WebLogic
•	Build: Maven

Project 3: Digit Institution’s 
Industry: Education
Description:
•	Worked as a Frontend and Backend Developer in the education domain, focusing on designing and developing user-friendly web interfaces. My responsibilities included implementing business logic, integrating third-party APIs, and developing backend modules for the online course and booking functionality offered by the institutions. 
Role: Junior Developer
Duration: Sep 2021 – Feb 2022
Responsibilities:
•	Designed and developed Restful services, actively participating in pre-inception meetings to gather and clarify requirements, ensuring alignment with project goals before initiating the design process.
•	Collaborate with project managers, designers, and other developers to align on project goals and deliverables.
•	Utilize PHP, Java and CodeIgniter for creating and managing RESTful APIs, integrating business logic, and handling backend processes.
•	Implement Java for complex business logic and ensure seamless integration with PHP services.
•	Integrate payment solutions like Paytm and Razor pay for order processing and payment transactions.
•	Implement SMS notifications using Text Local API to send notifications.
•	Develop and maintain the core business logic for course management, including user registration, course bookings, and payment processes.
•	Implement calendar activities to track and manage course schedules and bookings.
•	Design and optimize MySQL databases to ensure efficient data storage and retrieval.
•	Write complex SQL queries to support application features, such as user management and transaction history.
•	Create responsive and modern user interfaces using HTML, CSS, and JavaScript ensuring compatibility across various devices.
•	Utilize Bootstrap for responsive design and layout structure.
•	Integrate jQuery and various JS plugins to enhance UI interactivity and improve user experience.
•	Ensure seamless integration between front-end and back-end components, including handling data flow between user interfaces and APIs.
•	Work with third-party services (payment gateways and SMS API’s) to ensure smooth operation and reliability.
•	Debug and troubleshoot issues that arise during development and testing phases.
•	Use Git for source control to manage code changes and collaborate effectively with team members.

Technologies Used:
•	Frontend: HTML, CSS, JavaScript
•	Back End: Java , PHP
•	Database: MySQL
•	Collaboration: Team documentation & knowledge sharing


Project 4: Sim And Sam’s 
Industry: Ecommerce
Description:
•	Worked as a Frontend and Backend Developer in the ecommerce domain, I focused on designing and developing user-friendly web interfaces. My responsibilities included implementing business logic, integrating third-party APIs, and developing backend modules for the online ordering play area and Functions organization. I utilized a web application with integrated notification APIs and payment APIs to enhance functionality and user experience.
Role: Junior Developer
Duration: Sep 2020 – Aug 2021
Responsibilities:
•	Design and develop user interfaces using HTML, CSS,  JavaScript and Jquery.
•	Use jQuery to enhance user interactions and improve user experience.
•	Seamlessly integrate front-end components with back-end services.
•	Design the model to represent application data and business logic.
•	Implement data validation, formatting, and interaction with MySQL databases.
•	Coordinate between models and views to deliver the right responses.
•	Monitor and optimize application performance by refining code and database queries.
•	Identify, troubleshoot, and fix issues in both front-end and back-end code.
•	Conduct unit tests and integration tests to ensure code quality and functionality.
•	Define and document API endpoints, specifying HTTP methods and data formats.
•	Develop authentication and authorization mechanisms.
•	Use tools like cURL interact with external APIs.
•	Secure API endpoints to prevent unauthorized access.

Technologies Used:
•	Frontend: HTML, CSS, JavaScript, jQuery , Ajax
•	Back End: Java , PHP
•	Database: MySQL
•	Collaboration: Team documentation & knowledge sharing

Higher Education
•	Sri Sai Institute Of Techknowlogy And Science, Rajachoty  - Master of Engineering
-	Computer Science Engineering , 07/2022.



